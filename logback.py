class Logback:
    '''
    This class represents the main holder for a logback.xml file. Important things to know:
    All the loggers are stored in self.loggers.
    The important information about the loggers are:
        logger.commented
        logger.name
        logger.level
    That is really most likely all you are going to care about.
    '''
    def __init__(self,val):
        '''
        create a logback class. The one argument is a string, the contents of logback.xml.
        '''

        #First step, check if this is a file that Octo created or if it is a virgin file.
        if "this had been generated by Octo." in val:
            self.generated = True
        else:
            self.generated = False

        #save the content of the string locally. Then find where the meat starts and finishes.
        self.content_string = val
        self.start = val.find("<configuration") + 1
        content_start = val.find(">",self.start) + 1
        self.end = val.find("</configuration>")

        #get whether this file is monitored. And check for what the frequency is.
        scanstart = val.find("scan=",self.start) + 6
        scanend = val.find('"',scanstart)
        self.scan = bool(val[scanstart:scanend])

        scanstart = val.find("scanPeriod=",self.start) + 12
        scanend = val.find(' ',scanstart)
        self.scanPeriod = int(val[scanstart:scanend])

        #find the context name for this logback file.
        self.contextName = self.getThing("contextName")
        #find the context listener
        self.contextListener = self.getThing("contextListener")
        #check if there is a jmx configurator
        self.jmxConfigurator = self.getJMX()

        #find where each of the appenders are. I believe these are the components that actually
        #write to the log file. More than one can write to one file, but each one writes to the log
        #with its own signature. I think.
        
        self.appenders = []#Instatiante the list of appenders.
        a = self.getThing("appender")#find the first appender.
        while a:#this will loop as long as there is another appender to process.
            self.appenders.append(Appender(a))#pass the string to the appender class.
            a = self.getThing("appender",self.lastend)#try to find the next appender.

        #appenders done, now we need to know what the default(root) logging level and appender are.
        self.root = self.getThing("root")

        #on to the meat at last! We now are going to find the loggers and process them.        
        self.loggers = [] #instantiate the loggers list.

        #This next part is a bit annoying but important. We keep track of whether we are currently
        #in a comment or not. This starts that process.
        openComment = val.find("<!--",self.lastend)
        closeComment = val.find("-->",openComment) + 3
        nextComment = val.find("<!--",closeComment)

        #commenting started we now start searching for the first logger, which may well be
        #commented out, so this gets fun right away. first, lets set defaults:
        l = self.getThing("logger",self.lastend)
        commented = False
        section = None

        #now loop until we get to the end of the long style loggers.
        while l:
            #if the end of the last item is past the next comment we need to update where our
            #comment markers are. 
            while self.lastend > nextComment:
                openComment = nextComment
                closeComment = val.find("-->",openComment) + 3
                nextComment = val.find("<!--",closeComment)
                
            #If the end of the last item is before the comment closes we know we are commented out.
            if self.lastend < closeComment:
                commented = True

                #this deals with sections ending. My head is hurting just trying to remember this.
                #but in short we are trying to gather the content from directly before this logger
                #that is residing in a comment, normally invisible to xml. 
                if val[openComment:self.laststart].count('\n') == 1:
                    secEnd = val.find("\n",openComment)
                    section = val[openComment+5:secEnd]
                    
            else:
                #if the comment ends after the comment closed, then we aren't in a commented area.
                commented = False
                if self.laststart > closeComment:
                    section = val[openComment+5:closeComment-4]
                else:
                    pass #huh, I never ended up using this.

            #FINALLY! extracted the logger string and the pertainent information on it. 
            logger = Logger(l,commented,section)

            #add that logger to the list.
            self.loggers.append(logger)
            
            #this will be used in a moment.
            templastend = self.lastend
            
            #Find the next logger.
            l = self.getThing("logger",self.lastend)


        #So someone thought it would be fun to have a short hand format for describing loggers
        #as well as the way already handled. So we have to repeat basically everything above to get
        #these little loggers as well.

        #I said this would be used shortly. temp last end is a variable for marking where the end
        #of the normal logs are. It's complicated, but it works.
        ll = val.find("<logger ",templastend)
        #little log (ll) find the end of it, since it's different from the other items.
        llend = val.find("/>",ll)+2
        while ll != -1:
            #This is the commenting goal post moving trick, same as above.
            while llend > nextComment:
                openComment = nextComment
                closeComment = val.find("-->",openComment) + 3
                nextComment = val.find("<!--",closeComment)
                if nextComment == -1:
                    nextComment = self.end

            if llend < closeComment:
                commented = True
                if val[openComment:llend].count('\n') < 3:
                    secEnd = val.find("\n",openComment)
                    section = val[openComment+5:secEnd]
            else:
                commented = False
                if ll > closeComment:
                    section = val[openComment+5:closeComment-4]
                else:
                    pass

            #found the little bastard. Now lets get string.
            l = val[ll:llend]

            #process it and add it to the list.
            logger = Logger(l,commented,section)
            self.loggers.append(logger)

            #move on, finding the next one.
            ll = val.find("<logger ",llend)
            llend = val.find("/>",ll)+2

        #and that's in for __init__. this was an exhausting class to write.

    def getThing(self,thing,start_val = 0):
        '''
        convenience method for getting xml tags.
        '''
        val = self.content_string
        start = val.find(thing,start_val)
        if start == -1:
            print("nothing found. ")
            return start
        start -= 1
        while val[start] != '\n':
            start -= 1
        start += 1
        end = val.find("</"+thing+">",start) + len("</"+thing+">")
        self.laststart = start
        self.lastend = end + 1
        #print(val[start:end])#,start,end)
        return val[start:end]

    def getJMX(self):
        #kinda like getThing, but specific to jmxConfigurator.
        if self.content_string.find("  <jmxConfigurator />") == -1:
            return None
        else:
            return "  <jmxConfigurator />"

    def __str__(self):
        '''
        This actually prints out the new logback file. Copy paste this and put it in the new file.
        '''
        outs = '<?xml version="1.0" encoding="UTF-8"?>\n<!-- this had been generated by Octo. You will have to re-deploy to get the original back-->\n'
        outs += '<configuration scan="{0}" scanPeriod="{1} seconds">\n\n'.format(self.scan,self.scanPeriod)

        outs += self.contextName + '\n\n'

        outs += self.contextListener + '\n\n'

        outs += self.jmxConfigurator + '\n\n'

        for appender in self.appenders:
            outs += str(appender)

        outs += '\n' + self.root + '\n'

        for logger in self.loggers:
            outs += str(logger)

        outs += '\n</configuration>'
        return outs

class Appender:
    def __init__(self,val):
        '''
        This is the wrapper class for the appenders. Pretty straight forward.
        '''
        self.content_string = val
        self.name = val[val.find('name=')+6:val.find('" c')]
        self.xclass = val[val.find('class=')+7:val.find('">')]
        self.file = val[val.find('<File>')+6:val.find('</File>')]
        self.encoder = val[val.find('<pattern>')+9:val.find('</pattern>')]
        temp = val.find('<rollingPolicy class=')
        self.rollingPolicyClass = val[temp+22:val.find('">',temp)]
        self.rollingPolicyFile = val[val.find('<fileNamePattern>')+17:val.find('</fileNamePattern>')]

    def __str__(self):
        appendstr = """
  <appender name="{0}" class="{1}">
    <File>{2}</File>
    <encoder>
      <pattern>{3}</pattern>
    </encoder>
    <rollingPolicy class="{4}">
      <fileNamePattern>{5}</fileNamePattern>
    </rollingPolicy>
  </appender>
  """
        outs = appendstr.format(self.name,self.xclass,self.file,self.encoder,self.rollingPolicyClass,self.rollingPolicyFile)

        return outs

class Logger:
    def __init__(self,val,commented,section):
        '''
        Wrapper class for the loggers. My head hurts. This one is a little more complicated, but
        you really don't need to touch it anyway.
        The important things you need to know:
        whether this logger is active is in self.commented
        The name is self.name.
        The level is self.level.
        '''
        self.content_string = val
        self.commented = commented
        self.section = section
        #print(val,commented,section)
        if not self.section:
            self.section = "None"
        while self.section[0] == ' ':
                self.section = self.section[1:]

        self.name = self.getXat("name")
        self.additivity = self.getXat("additivity")
        self.level = self.getXat("level")

        if val.find("appender-ref") != -1:
            self.appender = self.getXat(" ref")
        else:
            self.appender = None

        #print(self.section)

    def __str__(self):
        wref = """
  <!-- {0} -->
  {5}<logger name="{1}" additivity="{2}" level="{3}">
    <appender-ref ref="{4}"/>
  </logger>{6}
  """
        oref = """
  <!-- {0} {4}-->
  {5}<logger name="{1}" additivity="{2}" level="{3}"/>{6}
"""
        if self.appender:
            ret = wref
            app = self.appender
        else:
            ret = oref
            app = ""

        if self.commented:
            o = "<!--"
            c = "-->"
        else:
            o = ""
            c = ""
        return ret.format(self.section,self.name,self.additivity,self.level.replace(' ',''),app,o,c)
        

    def getXat(self,foo):
        val = self.content_string
        start = val.find(foo)+len(foo)+2
        end = val.find('"',start+1)
        return val[start:end]

if __name__ == "__main__":
    f = open("logback.dev.xml","r")
    content_string = f.read()
    l = Logback(content_string)
    print(l)
